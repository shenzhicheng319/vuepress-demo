<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>目录 | 西索的博客</title>
    <meta name="generator" content="VuePress 1.5.0">
    <link rel="icon" href="/picture.jpg">
    <link rel="manifest" href="/picture.jpg">
    <link rel="apple-touch-icon" href="/picture.jpg">
    <meta name="description" content="">
    <link rel="preload" href="/assets/css/0.styles.69cc6ed9.css" as="style"><link rel="preload" href="/assets/js/app.f16b6530.js" as="script"><link rel="preload" href="/assets/js/2.efd5ddf9.js" as="script"><link rel="preload" href="/assets/js/3.1fdb5907.js" as="script"><link rel="prefetch" href="/assets/js/4.afedb2a7.js"><link rel="prefetch" href="/assets/js/5.06223f8f.js"><link rel="prefetch" href="/assets/js/6.bc465d58.js"><link rel="prefetch" href="/assets/js/7.5a53c1b3.js"><link rel="prefetch" href="/assets/js/8.036f5b90.js">
    <link rel="stylesheet" href="/assets/css/0.styles.69cc6ed9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/picture.jpg" alt="西索的博客" class="logo"> <span class="site-name can-hide">西索的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/tech/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  技术文档
</a></div><div class="nav-item"><a href="/testDemo/" class="nav-link">
  testDemo
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/tech/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  技术文档
</a></div><div class="nav-item"><a href="/testDemo/" class="nav-link">
  testDemo
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>目录</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/tech/#前言" class="sidebar-link">前言</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#面试相关" class="sidebar-link">面试相关</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#随笔记录" class="sidebar-link">随笔记录</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#html相关" class="sidebar-link">html相关</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#css相关" class="sidebar-link">css相关</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tech/#_1、垂直对齐" class="sidebar-link">1、垂直对齐</a></li><li class="sidebar-sub-header"><a href="/tech/#_2、伸展一个元素到窗口高度" class="sidebar-link">2、伸展一个元素到窗口高度</a></li><li class="sidebar-sub-header"><a href="/tech/#_3、基于文件格式使用不同的样式" class="sidebar-link">3、基于文件格式使用不同的样式</a></li><li class="sidebar-sub-header"><a href="/tech/#_4、背景渐变动画" class="sidebar-link">4、背景渐变动画</a></li><li class="sidebar-sub-header"><a href="/tech/#_5、css：表格列宽自适用" class="sidebar-link">5、CSS：表格列宽自适用</a></li><li class="sidebar-sub-header"><a href="/tech/#_6、只在一边或两边显示盒子阴影" class="sidebar-link">6、只在一边或两边显示盒子阴影</a></li><li class="sidebar-sub-header"><a href="/tech/#_7、包裹长文本" class="sidebar-link">7、包裹长文本</a></li><li class="sidebar-sub-header"><a href="/tech/#_8、制造模糊文本" class="sidebar-link">8、制造模糊文本</a></li><li class="sidebar-sub-header"><a href="/tech/#_9、用css动画实现省略号动画" class="sidebar-link">9、用CSS动画实现省略号动画</a></li><li class="sidebar-sub-header"><a href="/tech/#_10、样式重置" class="sidebar-link">10、样式重置</a></li><li class="sidebar-sub-header"><a href="/tech/#_11、典型的css清除浮动" class="sidebar-link">11、典型的CSS清除浮动</a></li><li class="sidebar-sub-header"><a href="/tech/#_12、新版清除浮动（2011）" class="sidebar-link">12、新版清除浮动（2011）</a></li><li class="sidebar-sub-header"><a href="/tech/#_13、跨浏览器的透明" class="sidebar-link">13、跨浏览器的透明</a></li><li class="sidebar-sub-header"><a href="/tech/#_14、通用媒体查询" class="sidebar-link">14、通用媒体查询</a></li><li class="sidebar-sub-header"><a href="/tech/#_15、自定义文本选择" class="sidebar-link">15、自定义文本选择</a></li><li class="sidebar-sub-header"><a href="/tech/#_16、为logo隐藏h1" class="sidebar-link">16、为logo隐藏H1</a></li><li class="sidebar-sub-header"><a href="/tech/#_17、锚链接伪类" class="sidebar-link">17、锚链接伪类</a></li><li class="sidebar-sub-header"><a href="/tech/#_18、css3：全屏背景" class="sidebar-link">18、CSS3：全屏背景</a></li><li class="sidebar-sub-header"><a href="/tech/#_19、内容垂直居中" class="sidebar-link">19、内容垂直居中</a></li><li class="sidebar-sub-header"><a href="/tech/#_20、强制出现垂直滚动条" class="sidebar-link">20、强制出现垂直滚动条</a></li><li class="sidebar-sub-header"><a href="/tech/#_21、css3渐变模板" class="sidebar-link">21、CSS3渐变模板</a></li><li class="sidebar-sub-header"><a href="/tech/#_22、css3-斑马线" class="sidebar-link">22、CSS3 斑马线</a></li><li class="sidebar-sub-header"><a href="/tech/#_23、内部css3-盒阴影" class="sidebar-link">23、内部CSS3 盒阴影</a></li><li class="sidebar-sub-header"><a href="/tech/#_24、外部css3-盒阴影" class="sidebar-link">24、外部CSS3 盒阴影</a></li><li class="sidebar-sub-header"><a href="/tech/#_25、三角形列表项目符号" class="sidebar-link">25、三角形列表项目符号</a></li><li class="sidebar-sub-header"><a href="/tech/#_26、固定宽度的居中布局" class="sidebar-link">26、固定宽度的居中布局</a></li><li class="sidebar-sub-header"><a href="/tech/#_27、css3-列文本" class="sidebar-link">27、CSS3 列文本</a></li><li class="sidebar-sub-header"><a href="/tech/#_28、css固定页脚" class="sidebar-link">28、CSS固定页脚</a></li><li class="sidebar-sub-header"><a href="/tech/#_29、跨浏览器设置最小高度" class="sidebar-link">29、跨浏览器设置最小高度</a></li><li class="sidebar-sub-header"><a href="/tech/#_30、css3-鲜艳的输入" class="sidebar-link">30、CSS3 鲜艳的输入</a></li><li class="sidebar-sub-header"><a href="/tech/#_31、基于文件类型的链接样式" class="sidebar-link">31、基于文件类型的链接样式</a></li><li class="sidebar-sub-header"><a href="/tech/#_32、强制换行" class="sidebar-link">32、强制换行</a></li><li class="sidebar-sub-header"><a href="/tech/#_33、在可点击的项目上强制手型" class="sidebar-link">33、在可点击的项目上强制手型</a></li><li class="sidebar-sub-header"><a href="/tech/#_34、css3对话气泡" class="sidebar-link">34、CSS3对话气泡</a></li><li class="sidebar-sub-header"><a href="/tech/#_35、h1-h5默认样式" class="sidebar-link">35、H1-H5默认样式</a></li><li class="sidebar-sub-header"><a href="/tech/#_36、css悬浮提示文本" class="sidebar-link">36、CSS悬浮提示文本</a></li><li class="sidebar-sub-header"><a href="/tech/#_37、深灰色的圆形按钮" class="sidebar-link">37、深灰色的圆形按钮</a></li><li class="sidebar-sub-header"><a href="/tech/#_38、在可打印的网页中显示urls" class="sidebar-link">38、在可打印的网页中显示URLs</a></li><li class="sidebar-sub-header"><a href="/tech/#_53、禁用移动webkit的选择高亮" class="sidebar-link">53、禁用移动Webkit的选择高亮</a></li><li class="sidebar-sub-header"><a href="/tech/#_39、css3-圆点图案" class="sidebar-link">39、CSS3 圆点图案</a></li><li class="sidebar-sub-header"><a href="/tech/#_40、css-font属性缩写" class="sidebar-link">40、CSS font属性缩写</a></li><li class="sidebar-sub-header"><a href="/tech/#_41、论文页面的卷曲效果" class="sidebar-link">41、论文页面的卷曲效果</a></li><li class="sidebar-sub-header"><a href="/tech/#_42、鲜艳的锚链接" class="sidebar-link">42、鲜艳的锚链接</a></li></ul></li><li><a href="/tech/#es6相关" class="sidebar-link">es6相关</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#_1-eacmscript与javascript的关系" class="sidebar-link">1\. EACMScript与JavaScript的关系</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#_2-babel-转码器" class="sidebar-link">2\. Babel 转码器</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#_1-let-的特性以及用法" class="sidebar-link">1\. let 的特性以及用法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#_2-const-特性以及方法" class="sidebar-link">2\. const 特性以及方法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#_3-顶层对象属性" class="sidebar-link">3\. 顶层对象属性</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#_1-对象的结构" class="sidebar-link">1\. 对象的结构</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#_2-数组的结构" class="sidebar-link">2\. 数组的结构</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#_3-参数的结构" class="sidebar-link">3\. 参数的结构</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#_4-其他的解构" class="sidebar-link">4\. 其他的解构</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#_1-更好的unicode支持" class="sidebar-link">1\. 更好的Unicode支持</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#_2-增加的字符串api-只举出工作中常用的四种" class="sidebar-link">2\. 增加的字符串API(只举出工作中常用的四种)</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#_3-模板字符串" class="sidebar-link">3\. 模板字符串</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#_1-在书写形参时，直接给形参赋值，附的值即为默认值（在解构的时候有过应用）" class="sidebar-link">1\. 在书写形参时，直接给形参赋值，附的值即为默认值（在解构的时候有过应用）</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#es6的剩余参数专门用于手机末尾的所有参数，将其放置到一个形参数组中。语法" class="sidebar-link">ES6的剩余参数专门用于手机末尾的所有参数，将其放置到一个形参数组中。语法:</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#_2-展开运算符：-要展开的东西" class="sidebar-link">2\. 展开运算符：...要展开的东西</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#_3-明确函数的双重用途" class="sidebar-link">3\. 明确函数的双重用途</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#_4-箭头函数" class="sidebar-link">4\. 箭头函数</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#js相关" class="sidebar-link">js相关</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#vuejs相关" class="sidebar-link">vuejs相关</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="目录"><a href="#目录" class="header-anchor">#</a> 目录</h1> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>与其羡慕旁人，不如朝这个方向努力变成你要的样子</p> <h2 id="面试相关"><a href="#面试相关" class="header-anchor">#</a> 面试相关</h2> <p>1.预留</p> <h2 id="随笔记录"><a href="#随笔记录" class="header-anchor">#</a> 随笔记录</h2> <p>想到什么记什么</p> <h2 id="html相关"><a href="#html相关" class="header-anchor">#</a> html相关</h2> <p>1.预留</p> <h2 id="css相关"><a href="#css相关" class="header-anchor">#</a> css相关</h2> <h3 id="_1、垂直对齐"><a href="#_1、垂直对齐" class="header-anchor">#</a> 1、垂直对齐</h3> <p>如果你用<code>CSS</code>，则你会有困惑：我该怎么垂直对齐容器中的元素？现在，利用<code>CSS3</code>的<code>Transform</code>，可以很优雅的解决这个困惑：</p> <div class="language- extra-class"><pre><code>.verticalcenter{
    position: relative;
    top: 50%;
    -webkit-transform: translateY(-50%);
    -o-transform: translateY(-50%);
    transform: translateY(-50%);
}
</code></pre></div><p>使用这个技巧，从单行文本、段落到box，都会垂直对齐。目前浏览器对<code>Transform</code>的支持是需要关注的，</p> <p><code>Chrome 4</code>, <code>Opera 10</code>, <code>Safari 3</code>, <code>Firefox 3</code>, <code>and Internet Explorer 9</code>均支持该属性</p> <h3 id="_2、伸展一个元素到窗口高度"><a href="#_2、伸展一个元素到窗口高度" class="header-anchor">#</a> 2、伸展一个元素到窗口高度</h3> <p>在具体场景中，你可能想要将一个元素伸展到窗口高度，基本元素的调整只能调整容器的大小,因此要使一个元素伸展到窗口高度，<br>
我们需要伸展顶层元素：<code>html</code>和<code>body</code>:</p> <div class="language- extra-class"><pre><code>html, 
body {
    height: 100%;
}
</code></pre></div><p>然后将<code>100%</code>应用到任何元素的高</p> <div class="language- extra-class"><pre><code>div {
    height: 100%;
}
</code></pre></div><h3 id="_3、基于文件格式使用不同的样式"><a href="#_3、基于文件格式使用不同的样式" class="header-anchor">#</a> 3、基于文件格式使用不同的样式</h3> <p>为了更容易知道链接的目标，有时你想让一些链接看起来和其它的不同。下面的片段在文本链接前添加一个图标，对不同的资源使用不同的图标或图片：</p> <div class="language- extra-class"><pre><code>a[href^=&quot;http://&quot;]{
    padding-right: 20px;
    background: url(external.gif) no-repeat center right;
}
/* emails */
a[href^=&quot;mailto:&quot;]{
    padding-right: 20px;
    background: url(email.png) no-repeat center right;
}

/* pdfs */
a[href$=&quot;.pdf&quot;]{
    padding-right: 20px;
    background: url(pdf.png) no-repeat center right;
}
</code></pre></div><h3 id="_4、背景渐变动画"><a href="#_4、背景渐变动画" class="header-anchor">#</a> 4、背景渐变动画</h3> <p><code>CSS</code>中最具诱惑的一个功能是能添加动画效果，除了渐变，你可以给背景色、透明度、元素大小添加动画。目前，你不能为渐变添加动画，但下面的代码可能有帮助。它通过改变背景位置，让它看起来有动画效果。</p> <div class="language- extra-class"><pre><code>button {
    background-image: linear-gradient(#5187c4, #1c2f45);
    background-size: auto 200%;
    background-position: 0 100%;
    transition: background-position 0.5s;
}    
button:hover {
    background-position: 0 0;
}
</code></pre></div><h3 id="_5、css：表格列宽自适用"><a href="#_5、css：表格列宽自适用" class="header-anchor">#</a> 5、CSS：表格列宽自适用</h3> <p>对于表格，当谈到调整列宽时，是比较痛苦的。然后，这里有一个可以使用的技巧：给<code>td</code>元素添加<code>white-space: nowrap;</code>能让文本正确的换行</p> <div class="language- extra-class"><pre><code>td {
    white-space: nowrap;
}
</code></pre></div><h3 id="_6、只在一边或两边显示盒子阴影"><a href="#_6、只在一边或两边显示盒子阴影" class="header-anchor">#</a> 6、只在一边或两边显示盒子阴影</h3> <p>如果你要一个盒阴影，试试这个技巧，能为任一边添加阴影。为了实现这个，首先定义一个有具体宽高的盒子，然后正确定位<code>:after</code>伪类。实现底边阴影的代码如下</p> <div class="language- extra-class"><pre><code>.box-shadow {
    background-color: #FF8020;
    width: 160px;
    height: 90px;
    margin-top: -45px;
    margin-left: -80px;
    position: absolute;
    top: 50%;
    left: 50%;
}
.box-shadow:after {
    content: &quot;&quot;;
    width: 150px;
    height: 1px;
    margin-top: 88px;
    margin-left: -75px;
    display: block;
    position: absolute;
    left: 50%;
    z-index: -1;
    -webkit-box-shadow: 0px 0px 8px 2px #000000;
       -moz-box-shadow: 0px 0px 8px 2px #000000;
            box-shadow: 0px 0px 8px 2px #000000;
}
</code></pre></div><h3 id="_7、包裹长文本"><a href="#_7、包裹长文本" class="header-anchor">#</a> 7、包裹长文本</h3> <p>如果你碰到一个比自身容器长的文本，这个技巧对你很有用。在这个示例中，默认时，不管容器的宽度，文本都将水平填充。</p> <p><img src="https://user-gold-cdn.xitu.io/2018/6/8/163de338b4442a5a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p> <p>简单的<code>CSS</code>代码就能在容器中调整文本：</p> <div class="language- extra-class"><pre><code>pre {
    white-space: pre-line;
    word-wrap: break-word;
}
</code></pre></div><p>效果看起来如下：</p> <p><img src="https://user-gold-cdn.xitu.io/2018/6/8/163de338b43df2e7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p> <h3 id="_8、制造模糊文本"><a href="#_8、制造模糊文本" class="header-anchor">#</a> 8、制造模糊文本</h3> <p>想要让文本模糊？可以使用<code>color</code>透明和<code>text-shadow</code>实现</p> <div class="language- extra-class"><pre><code>.blurry-text {
   color: transparent;
   text-shadow: 0 0 5px rgba(0,0,0,0.5);
}
</code></pre></div><h3 id="_9、用css动画实现省略号动画"><a href="#_9、用css动画实现省略号动画" class="header-anchor">#</a> 9、用CSS动画实现省略号动画</h3> <p>这个片段将帮助你制造一个<code>ellipsis</code>的动画，对于简单的加载状态是很有用的，而不用去使用<code>gif</code>图像。</p> <div class="language- extra-class"><pre><code>.loading:after {
    overflow: hidden;
    display: inline-block;
    vertical-align: bottom;
    animation: ellipsis 2s infinite;
    content: &quot;\2026&quot;; /* ascii code for the ellipsis character */
}
@keyframes ellipsis {
    from {
        width: 2px;
    }
    to {
        width: 15px;
    }
}
</code></pre></div><h3 id="_10、样式重置"><a href="#_10、样式重置" class="header-anchor">#</a> 10、样式重置</h3> <div class="language- extra-class"><pre><code>html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
  font-size: 100%;
  font: inherit;
  vertical-align: baseline;
  outline: none;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}
html { height: 101%; }
body { font-size: 62.5%; line-height: 1; font-family: Arial, Tahoma, sans-serif; }
article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section { display: block; }
ol, ul { list-style: none; }
blockquote, q { quotes: none; }
blockquote:before, blockquote:after, q:before, q:after { content: ''; content: none; }
strong { font-weight: bold; } 
table { border-collapse: collapse; border-spacing: 0; }
img { border: 0; max-width: 100%; }
p { font-size: 1.2em; line-height: 1.0em; color: #333; }
</code></pre></div><h3 id="_11、典型的css清除浮动"><a href="#_11、典型的css清除浮动" class="header-anchor">#</a> 11、典型的CSS清除浮动</h3> <div class="language- extra-class"><pre><code>.clearfix:after {
 content: &quot;.&quot;; 
 display: block;
 clear: both;
 visibility: hidden;
 line-height: 0;
 height: 0; 
}
.clearfix { display: inline-block; }
html[xmlns] .clearfix { display: block; }
* html .clearfix { height: 1%; }
</code></pre></div><h3 id="_12、新版清除浮动（2011）"><a href="#_12、新版清除浮动（2011）" class="header-anchor">#</a> 12、新版清除浮动（2011）</h3> <div class="language- extra-class"><pre><code>.clearfix:before, .container:after { content: &quot;&quot;; display: table; }
.clearfix:after { clear: both; }
/* IE 6/7 */
.clearfix { zoom: 1; }
</code></pre></div><h3 id="_13、跨浏览器的透明"><a href="#_13、跨浏览器的透明" class="header-anchor">#</a> 13、跨浏览器的透明</h3> <div class="language- extra-class"><pre><code>.transparent {
    filter: alpha(opacity=50); /* internet explorer */
    -khtml-opacity: 0.5;      /* khtml, old safari */
    -moz-opacity: 0.5;       /* mozilla, netscape */
    opacity: 0.5;           /* fx, safari, opera */
}
</code></pre></div><h3 id="_14、通用媒体查询"><a href="#_14、通用媒体查询" class="header-anchor">#</a> 14、通用媒体查询</h3> <div class="language- extra-class"><pre><code>/* Smartphones (portrait and landscape) ----------- */
@media only screen 
and (min-device-width : 320px) and (max-device-width : 480px) {
  /* Styles */
}
/* Smartphones (landscape) ----------- */
@media only screen and (min-width : 321px) {
  /* Styles */
}
/* Smartphones (portrait) ----------- */
@media only screen and (max-width : 320px) {
  /* Styles */
}
/* iPads (portrait and landscape) ----------- */
@media only screen and (min-device-width : 768px) and (max-device-width : 1024px) {
  /* Styles */
}
/* iPads (landscape) ----------- */
@media only screen and (min-device-width : 768px) and (max-device-width : 1024px) and (orientation : landscape) {
  /* Styles */
}
/* iPads (portrait) ----------- */
@media only screen and (min-device-width : 768px) and (max-device-width : 1024px) and (orientation : portrait) {
  /* Styles */
}
/* Desktops and laptops ----------- */
@media only screen and (min-width : 1224px) {
  /* Styles */
}
/* Large screens ----------- */
@media only screen and (min-width : 1824px) {
  /* Styles */
}
/* iPhone 4 ----------- */
@media only screen and (-webkit-min-device-pixel-ratio:1.5), only screen and (min-device-pixel-ratio:1.5) {
  /* Styles */
}
</code></pre></div><h3 id="_15、自定义文本选择"><a href="#_15、自定义文本选择" class="header-anchor">#</a> 15、自定义文本选择</h3> <div class="language- extra-class"><pre><code>::selection { background: #e2eae2; }
::-moz-selection { background: #e2eae2; }
::-webkit-selection { background: #e2eae2; }
</code></pre></div><h3 id="_16、为logo隐藏h1"><a href="#_16、为logo隐藏h1" class="header-anchor">#</a> 16、为logo隐藏H1</h3> <div class="language- extra-class"><pre><code>h1 {
    text-indent: -9999px;
    margin: 0 auto;
    width: 320px;
    height: 85px;
    background: transparent url(&quot;images/logo.png&quot;) no-repeat scroll;
}
</code></pre></div><h3 id="_17、锚链接伪类"><a href="#_17、锚链接伪类" class="header-anchor">#</a> 17、锚链接伪类</h3> <div class="language- extra-class"><pre><code>a:link { color: blue; }
a:visited { color: purple; }
a:hover { color: red; }
a:active { color: yellow; }
</code></pre></div><h3 id="_18、css3：全屏背景"><a href="#_18、css3：全屏背景" class="header-anchor">#</a> 18、CSS3：全屏背景</h3> <div class="language- extra-class"><pre><code>html { 
    background: url('images/bg.jpg') no-repeat center center fixed; 
    -webkit-background-size: cover;
    -moz-background-size: cover;
    -o-background-size: cover;
    background-size: cover;
}
</code></pre></div><h3 id="_19、内容垂直居中"><a href="#_19、内容垂直居中" class="header-anchor">#</a> 19、内容垂直居中</h3> <div class="language- extra-class"><pre><code>.container {
    min-height: 6.5em;
    display: table-cell;
    vertical-align: middle;
} 
</code></pre></div><h3 id="_20、强制出现垂直滚动条"><a href="#_20、强制出现垂直滚动条" class="header-anchor">#</a> 20、强制出现垂直滚动条</h3> <div class="language- extra-class"><pre><code>html { height: 101% }
</code></pre></div><h3 id="_21、css3渐变模板"><a href="#_21、css3渐变模板" class="header-anchor">#</a> 21、CSS3渐变模板</h3> <div class="language- extra-class"><pre><code>#colorbox {
    background: #629721;
    background-image: -webkit-gradient(linear, left top, left bottom, from(#83b842), to(#629721));
    background-image: -webkit-linear-gradient(top, #83b842, #629721);
    background-image: -moz-linear-gradient(top, #83b842, #629721);
    background-image: -ms-linear-gradient(top, #83b842, #629721);
    background-image: -o-linear-gradient(top, #83b842, #629721);
    background-image: linear-gradient(top, #83b842, #629721);
}
</code></pre></div><h3 id="_22、css3-斑马线"><a href="#_22、css3-斑马线" class="header-anchor">#</a> 22、CSS3 斑马线</h3> <div class="language- extra-class"><pre><code>tbody tr:nth-child(odd) {
    background-color: #ccc;
}
</code></pre></div><h3 id="_23、内部css3-盒阴影"><a href="#_23、内部css3-盒阴影" class="header-anchor">#</a> 23、内部CSS3 盒阴影</h3> <div class="language- extra-class"><pre><code>#mydiv { 
    -moz-box-shadow: inset 2px 0 4px #000;
    -webkit-box-shadow: inset 2px 0 4px #000;
    box-shadow: inset 2px 0 4px #000;
}
</code></pre></div><h3 id="_24、外部css3-盒阴影"><a href="#_24、外部css3-盒阴影" class="header-anchor">#</a> 24、外部CSS3 盒阴影</h3> <div class="language- extra-class"><pre><code>#mydiv { 
    -webkit-box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52);
    -moz-box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52);
    box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52);
}
</code></pre></div><h3 id="_25、三角形列表项目符号"><a href="#_25、三角形列表项目符号" class="header-anchor">#</a> 25、三角形列表项目符号</h3> <div class="language- extra-class"><pre><code>ul {
    margin: 0.75em 0;
    padding: 0 1em;
    list-style: none;
}
li:before { 
    content: &quot;&quot;;
    border-color: transparent #111;
    border-style: solid;
    border-width: 0.35em 0 0.35em 0.45em;
    display: block;
    height: 0;
    width: 0;
    left: -1em;
    top: 0.9em;
    position: relative;
}
</code></pre></div><h3 id="_26、固定宽度的居中布局"><a href="#_26、固定宽度的居中布局" class="header-anchor">#</a> 26、固定宽度的居中布局</h3> <div class="language- extra-class"><pre><code>#page-wrap {
    width: 800px;
    margin: 0 auto;
}
</code></pre></div><h3 id="_27、css3-列文本"><a href="#_27、css3-列文本" class="header-anchor">#</a> 27、CSS3 列文本</h3> <div class="language- extra-class"><pre><code>#columns-3 {
    text-align: justify;
    -moz-column-count: 3;
    -moz-column-gap: 12px;
    -moz-column-rule: 1px solid #c4c8cc;
    -webkit-column-count: 3;
    -webkit-column-gap: 12px;
    -webkit-column-rule: 1px solid #c4c8cc;
}
</code></pre></div><h3 id="_28、css固定页脚"><a href="#_28、css固定页脚" class="header-anchor">#</a> 28、CSS固定页脚</h3> <div class="language- extra-class"><pre><code>#footer {
    position: fixed;
    left: 0px;
    bottom: 0px;
    height: 30px;
    width: 100%;
    background: #444;
}
/* IE 6 */
* html #footer {
    position: absolute;
    top: expression((0-(footer.offsetHeight)+(document.documentElement.clientHeight ? document.documentElement.clientHeight : document.body.clientHeight)+(ignoreMe = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop))+'px');
}
</code></pre></div><h3 id="_29、跨浏览器设置最小高度"><a href="#_29、跨浏览器设置最小高度" class="header-anchor">#</a> 29、跨浏览器设置最小高度</h3> <div class="language- extra-class"><pre><code>#container {
    min-height: 550px;
    height: auto !important;
    height: 550px;
}
</code></pre></div><h3 id="_30、css3-鲜艳的输入"><a href="#_30、css3-鲜艳的输入" class="header-anchor">#</a> 30、CSS3 鲜艳的输入</h3> <div class="language- extra-class"><pre><code>input[type=text], textarea {
    -webkit-transition: all 0.30s ease-in-out;
    -moz-transition: all 0.30s ease-in-out;
    -ms-transition: all 0.30s ease-in-out;
    -o-transition: all 0.30s ease-in-out;
    outline: none;
    padding: 3px 0px 3px 3px;
    margin: 5px 1px 3px 0px;
    border: 1px solid #ddd;
}
input[type=text]:focus, textarea:focus {
    box-shadow: 0 0 5px rgba(81, 203, 238, 1);
    padding: 3px 0px 3px 3px;
    margin: 5px 1px 3px 0px;
    border: 1px solid rgba(81, 203, 238, 1);
}
</code></pre></div><h3 id="_31、基于文件类型的链接样式"><a href="#_31、基于文件类型的链接样式" class="header-anchor">#</a> 31、基于文件类型的链接样式</h3> <div class="language- extra-class"><pre><code>/* external links */
a[href^=&quot;http://&quot;] {
    padding-right: 13px;
    background: url('external.gif') no-repeat center right;
}
/* emails */
a[href^=&quot;mailto:&quot;] {
    padding-right: 20px;
    background: url('email.png') no-repeat center right;
}
/* pdfs */
a[href$=&quot;.pdf&quot;] {
    padding-right: 18px;
    background: url('acrobat.png') no-repeat center right;
}
</code></pre></div><h3 id="_32、强制换行"><a href="#_32、强制换行" class="header-anchor">#</a> 32、强制换行</h3> <div class="language- extra-class"><pre><code>pre {
    white-space: pre-wrap;       /* css-3 */
    white-space: -moz-pre-wrap;  /* Mozilla, since 1999 */
    white-space: -pre-wrap;      /* Opera 4-6 */
    white-space: -o-pre-wrap;    /* Opera 7 */
    word-wrap: break-word;       /* Internet Explorer 5.5+ */
}
</code></pre></div><h3 id="_33、在可点击的项目上强制手型"><a href="#_33、在可点击的项目上强制手型" class="header-anchor">#</a> 33、在可点击的项目上强制手型</h3> <div class="language- extra-class"><pre><code>a[href], input[type='submit'], input[type='image'], label[for], select, button, .pointer {
    cursor: pointer;
}
</code></pre></div><h3 id="_34、css3对话气泡"><a href="#_34、css3对话气泡" class="header-anchor">#</a> 34、CSS3对话气泡</h3> <div class="language- extra-class"><pre><code>.chat-bubble {
    background-color: #ededed;
    border: 2px solid #666;
    font-size: 35px;
    line-height: 1.3em;
    margin: 10px auto;
    padding: 10px;
    position: relative;
    text-align: center;
    width: 300px;
    -moz-border-radius: 20px;
    -webkit-border-radius: 20px;
    -moz-box-shadow: 0 0 5px #888;
    -webkit-box-shadow: 0 0 5px #888;
    font-family: 'Bangers', arial, serif; 
}
.chat-bubble-arrow-border {
    border-color: #666 transparent transparent transparent;
    border-style: solid;
    border-width: 20px;
    height: 0;
    width: 0;
    position: absolute;
    bottom: -42px;
    left: 30px;
}
.chat-bubble-arrow {
    border-color: #ededed transparent transparent transparent;
    border-style: solid;
    border-width: 20px;
    height: 0;
    width: 0;
    position: absolute;
    bottom: -39px;
    left: 30px;
}
</code></pre></div><h3 id="_35、h1-h5默认样式"><a href="#_35、h1-h5默认样式" class="header-anchor">#</a> 35、H1-H5默认样式</h3> <div class="language- extra-class"><pre><code>h1,h2,h3,h4,h5{
    color: #005a9c;
}
h1{
    font-size: 2.6em;
    line-height: 2.45em;
}
h2{
    font-size: 2.1em;
    line-height: 1.9em;
}
h3{
    font-size: 1.8em;
    line-height: 1.65em;
}
h4{
    font-size: 1.65em;
    line-height: 1.4em;
}
h5{
    font-size: 1.4em;
    line-height: 1.25em;
}
</code></pre></div><h3 id="_36、css悬浮提示文本"><a href="#_36、css悬浮提示文本" class="header-anchor">#</a> 36、CSS悬浮提示文本</h3> <div class="language- extra-class"><pre><code>a { 
    border-bottom:1px solid #bbb;
    color:#666;
    display:inline-block;
    position:relative;
    text-decoration:none;
}
a:hover,
a:focus {
    color:#36c;
}
a:active {
    top:1px; 
}
/* Tooltip styling */
a[data-tooltip]:after {
    border-top: 8px solid #222;
    border-top: 8px solid hsla(0,0%,0%,.85);
    border-left: 8px solid transparent;
    border-right: 8px solid transparent;
    content: &quot;&quot;;
    display: none;
    height: 0;
    width: 0;
    left: 25%;
    position: absolute;
}
a[data-tooltip]:before {
    background: #222;
    background: hsla(0,0%,0%,.85);
    color: #f6f6f6;
    content: attr(data-tooltip);
    display: none;
    font-family: sans-serif;
    font-size: 14px;
    height: 32px;
    left: 0;
    line-height: 32px;
    padding: 0 15px;
    position: absolute;
    text-shadow: 0 1px 1px hsla(0,0%,0%,1);
    white-space: nowrap;
    -webkit-border-radius: 5px;
    -moz-border-radius: 5px;
    -o-border-radius: 5px;
    border-radius: 5px;
}
a[data-tooltip]:hover:after {
    display: block;
    top: -9px;
}
a[data-tooltip]:hover:before {
    display: block;
    top: -41px;
}
a[data-tooltip]:active:after {
    top: -10px;
}
a[data-tooltip]:active:before {
    top: -42px;
}
</code></pre></div><h3 id="_37、深灰色的圆形按钮"><a href="#_37、深灰色的圆形按钮" class="header-anchor">#</a> 37、深灰色的圆形按钮</h3> <div class="language- extra-class"><pre><code>.graybtn {
    -moz-box-shadow:inset 0px 1px 0px 0px #ffffff;
    -webkit-box-shadow:inset 0px 1px 0px 0px #ffffff;
    box-shadow:inset 0px 1px 0px 0px #ffffff;
    background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #ffffff), color-stop(1, #d1d1d1) );
    background:-moz-linear-gradient( center top, #ffffff 5%, #d1d1d1 100% );
    filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffffff', endColorstr='#d1d1d1');
    background-color:#ffffff;
    -moz-border-radius:6px;
    -webkit-border-radius:6px;
    border-radius:6px;
    border:1px solid #dcdcdc;
    display:inline-block;
    color:#777777;
    font-family:arial;
    font-size:15px;
    font-weight:bold;
    padding:6px 24px;
    text-decoration:none;
    text-shadow:1px 1px 0px #ffffff;
}
.graybtn:hover {
    background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #d1d1d1), color-stop(1, #ffffff) );
    background:-moz-linear-gradient( center top, #d1d1d1 5%, #ffffff 100% );
    filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#d1d1d1', endColorstr='#ffffff');
    background-color:#d1d1d1;
}
.graybtn:active {
    position:relative;
    top:1px;
}
</code></pre></div><h3 id="_38、在可打印的网页中显示urls"><a href="#_38、在可打印的网页中显示urls" class="header-anchor">#</a> 38、在可打印的网页中显示URLs</h3> <div class="language- extra-class"><pre><code>@media print   {  
  a:after {  
    content: &quot; [&quot; attr(href) &quot;] &quot;;  
  }  
}
</code></pre></div><h3 id="_53、禁用移动webkit的选择高亮"><a href="#_53、禁用移动webkit的选择高亮" class="header-anchor">#</a> 53、禁用移动Webkit的选择高亮</h3> <div class="language- extra-class"><pre><code>body {
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}
</code></pre></div><h3 id="_39、css3-圆点图案"><a href="#_39、css3-圆点图案" class="header-anchor">#</a> 39、CSS3 圆点图案</h3> <div class="language- extra-class"><pre><code>body {
    background: radial-gradient(circle, white 10%, transparent 10%),
    radial-gradient(circle, white 10%, black 10%) 50px 50px;
    background-size: 100px 100px;
}
</code></pre></div><h3 id="_40、css-font属性缩写"><a href="#_40、css-font属性缩写" class="header-anchor">#</a> 40、CSS font属性缩写</h3> <div class="language- extra-class"><pre><code>p {
  font: italic small-caps bold 1.2em/1.0em Arial, Tahoma, Helvetica;
}
</code></pre></div><h3 id="_41、论文页面的卷曲效果"><a href="#_41、论文页面的卷曲效果" class="header-anchor">#</a> 41、论文页面的卷曲效果</h3> <div class="language- extra-class"><pre><code>ul.box {
    position: relative;
    z-index: 1; /* prevent shadows falling behind containers with backgrounds */
    overflow: hidden;
    list-style: none;
    margin: 0;
    padding: 0; 
}
ul.box li {
    position: relative;
    float: left;
    width: 250px;
    height: 150px;
    padding: 0;
    border: 1px solid #efefef;
    margin: 0 30px 30px 0;
    background: #fff;
    -webkit-box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset;
    -moz-box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset; 
    box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset; 
}
ul.box li:before,
ul.box li:after {
    content: '';
    z-index: -1;
    position: absolute;
    left: 10px;
    bottom: 10px;
    width: 70%;
    max-width: 300px; /* avoid rotation causing ugly appearance at large container widths */
    max-height: 100px;
    height: 55%;
    -webkit-box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
    -moz-box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
    -webkit-transform: skew(-15deg) rotate(-6deg);
    -moz-transform: skew(-15deg) rotate(-6deg);
    -ms-transform: skew(-15deg) rotate(-6deg);
    -o-transform: skew(-15deg) rotate(-6deg);
    transform: skew(-15deg) rotate(-6deg); 
}
ul.box li:after {
    left: auto;
    right: 10px;
    -webkit-transform: skew(15deg) rotate(6deg);
    -moz-transform: skew(15deg) rotate(6deg);
    -ms-transform: skew(15deg) rotate(6deg);
    -o-transform: skew(15deg) rotate(6deg);
    transform: skew(15deg) rotate(6deg); 
}
</code></pre></div><h3 id="_42、鲜艳的锚链接"><a href="#_42、鲜艳的锚链接" class="header-anchor">#</a> 42、鲜艳的锚链接</h3> <div class="language- extra-class"><pre><code>a {
    color: #00e;
}
a:visited {
    color: #551a8b;
}
a:hover {
    color: #06e;
}
a:focus {
    outline: thin dotted;
}
a:hover, a:active {
    outline: 0;
}
a, a:visited, a:active {
    text-decoration: none;
    color: #fff;
    -webkit-transition: all .3s ease-in-out;
}
a:hover, .glow {
    color: #ff0;
    text-shadow: 0 0 10px #ff0;
}
</code></pre></div><h2 id="es6相关"><a href="#es6相关" class="header-anchor">#</a> es6相关</h2> <p>ES6总结篇（一）小弟的第一滴血，希望大家多多包涵哈</p> <p>简介</p> <p>相信大家都看过<strong>阮一峰老师</strong>的《ECMAScript6简介》，博主也读过很多次了，每次阅读都有新的收获，然后博主打算整理成一套完整笔记，做一套<strong>ES6总结系列</strong>。老话常说，<strong>读书先把厚书读薄，然后再把薄书读厚</strong>，博主现在做的事是把书读薄的过程，当然了，也是为了方便大家快速的了解ES6的特性以及本书的重要知识点，废话不多说，直接开车。</p> <h1 id="第一章、eacmscript-6-简介"><a href="#第一章、eacmscript-6-简介" class="header-anchor">#</a> 第一章、EACMScript 6 简介</h1> <h2 id="_1-eacmscript与javascript的关系"><a href="#_1-eacmscript与javascript的关系" class="header-anchor">#</a> 1. EACMScript与JavaScript的关系</h2> <p>大家对JavaScript起源都有一定了解，这个就不再赘述，直接引用ES6的总结：</p> <div class="language- extra-class"><pre><code>ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。
另外的 ECMAScript 方言还有 JScript 和ActionScript。日常场合，这两个词是可以互换的。
</code></pre></div><h2 id="_2-babel-转码器"><a href="#_2-babel-转码器" class="header-anchor">#</a> 2. Babel 转码器</h2> <ol><li><strong>Babel的作用</strong></li></ol> <ul><li><p>1.1 <strong>Babel</strong> babeljs.io/ 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在老版本的浏览器执行</p> <p>// 转码前
input.map(item =&gt; item + 1);</p> <p>// 转码后
input.map(function (item) {
return item + 1;
});</p></li></ul> <p>由于ES6有兼容性问题，导致有些语法糖不能在某些浏览器上正确执行，经过<strong>Babel</strong>转码之后变成大家都兼容的ES5，就可以正常执行了。</p> <ol start="2"><li><strong>安装以及配置</strong></li></ol> <ul><li><p>2.2.1 在项目的命令行安装 <code>$ npm install --save-dev @babel/core</code></p></li> <li><p>2.2.2 <strong>.babelrc文件</strong>用来设置转码规则和插件，基本规格如下：</p> <p>{
&quot;presets&quot;: [
&quot;@babel/env&quot;, //最新转码规则
&quot;@babel/preset-react&quot; //react 转码规则
],
&quot;plugins&quot;: []
}</p></li></ul> <p>presets字段设定转码规则： 官方提供以下的规则集(需要先安装再在**.babelrc文件**中使用，安装如下)</p> <div class="language- extra-class"><pre><code># 最新转码规则
$ npm install --save-dev @babel/preset-env
# react 转码规则
$ npm install --save-dev @babel/preset-reac
</code></pre></div><p><strong>注意，以下所有 Babel 工具和模块的使用，都必须先写好.babelrc。</strong></p> <ul><li><p>2.2.3 <strong>命令行工具@babel/cli、@babel/node、@babel/register</strong> 它的安装命令如下：</p> <p>$ npm install --save-dev @babel/cli
$ npm install --save-dev @babel/node #提供一个支持 ES6 的 REPL 环境
$ npm install --save-dev @babel/register
#改写require命令，为它加上一个钩子。
#每当使用require加载.js、.jsx、.es和.es6
#后缀名的文件，就会先用 Babel 进行转码</p></li></ul> <p>@babel/cli 基本用法（<strong>babel指令</strong>）：</p> <div class="language- extra-class"><pre><code># 转码结果输出到标准输出
$ npx babel example.js

# 转码结果写入一个文件
# --out-file 或 -o 参数指定输出文件
$ npx babel example.js --out-file compiled.js
# 或者
$ npx babel example.js -o compiled.js

# 整个目录转码
# --out-dir 或 -d 参数指定输出目录
$ npx babel src --out-dir lib
# 或者
$ npx babel src -d lib

# -s 参数生成source map文件
$ npx babel src -d lib -s
</code></pre></div><p>@babel/node 基本用法（<strong>babel-node指令</strong>）</p> <div class="language- extra-class"><pre><code>$ npx babel-node
&gt; (x =&gt; x * 2)(1)
2
</code></pre></div><p>@babel/register 基本用法</p> <div class="language- extra-class"><pre><code>//使用时必须首先加载@babel/register
require('@babel/register');
require('./es6.js');
</code></pre></div><ul><li><p>2.2.4 polyfill （用来转换babel无法转换的API以及一些语法） 使用core-js和<strong>regenerator-runtime(提供generator函数的转码)</strong>。</p></li> <li><p>安装：<code>$ npm install --save-dev core-js regenerator-runtime</code></p></li> <li><p>使用</p> <p>import 'core-js';
import 'regenerator-runtime/runtime';
// 或者
require('core-js');
require('regenerator-runtime/runtime);</p></li></ul> <p>Babel 默认不转码的 API 非常多，详细清单可以查看babel-plugin-transform-runtime模块的<a href="definitions.js">github.com/babel/babel…</a>文件</p> <ul><li><p><strong>浏览器环境</strong></p></li> <li><p>Babel 也可以用于浏览器环境，使用@babel/standalone模块提供的浏览器版本，将其插入网页。</p></li></ul> <p>注意，网页实时将 ES6 代码转为 ES5，对性能会有影响。生产环境需要加载已经转码完成的脚本。</p> <p>Babel 提供一个REPL 在线编译器，可以在线将 ES6 代码转为 ES5 代码。转换后的代码，可以直接作为 ES5 代码插入网页运行。</p> <h1 id="第二章、let-和-const-命令"><a href="#第二章、let-和-const-命令" class="header-anchor">#</a> 第二章、let 和 const 命令</h1> <h2 id="_1-let-的特性以及用法"><a href="#_1-let-的特性以及用法" class="header-anchor">#</a> 1. let 的特性以及用法</h2> <ol><li>首先，我先总结一下<strong>var</strong>缺点</li></ol> <ul><li><p>1.1 允许重复的变量声明：导致数据被覆盖</p></li> <li><p>1.2 变量提升：怪异的数据访问、闭包问题</p></li> <li><p>1.3 全局变量挂载到全局对象：全局对象成员污染问题</p> <p>// 1. 允许重复的变量声明：导致数据被覆盖
var a = 1;
function print(){
console.log(a)
}
// 假设这里有一千行代码
var a = 2;
print(); // 2</p> <p>// 2. 变量提升：怪异的数据访问</p> <p>if (Math.random() &lt; 0.5) {
var a = &quot;abc&quot;;
console.log(a);
}
else {
console.log(a);
}
console.log(a); // 无论怎样访问都是abc</p> <p>// 3. 全局变量挂载到全局对象：全局对象成员污染问题</p> <p>var abc = &quot;123&quot;;
console.log(window.abc); // 123</p> <p>// var console = &quot;abc&quot;;
// console.log(console) // abc 这个很可怕</p></li></ul> <ol start="2"><li>let (完美的解决了这些问题)
<ol><li>let声明的变量不会挂载到全局对象</li> <li>let声明的变量，不允许当前作用域范围内重复声明</li> <li>使用let不会有变量提升，因此，不能在定义let变量之前使用它(形成暂时性死区)</li></ol></li></ol> <ul><li><p><strong>暂时性死区</strong>：在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p></li> <li><p><strong>块级作用域</strong>：代码执行时遇到花括号，会创建一个块级作用域，花括号结束，销毁块级作用域</p> <p>// 1. let声明的变量不会挂载到全局对象</p> <p>let a = 123;
console.log(window.a) // undefined</p> <p>// 2. let声明的变量，不允许当前作用域范围内重复声明</p> <p>if (Math.random() &lt; 0.5) {
let a = 123; //定义在当前块级作用域
console.log(a) //当前块级作用域中的a
} else {
//这是另外一个块级作用域，该作用域中找不到a
console.log(a)
}</p> <p>//3. 使用let不会有变量提升，因此，不能在定义let变量之前使用它</p> <p>console(c); // Uncaught ReferenceError: c is not defined 形成了暂时性死区
let c = 6;</p></li></ul> <p><strong>暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</strong></p> <h2 id="_2-const-特性以及方法"><a href="#_2-const-特性以及方法" class="header-anchor">#</a> 2. const 特性以及方法</h2> <ul><li>const和let完全相同，仅在于用const声明的变量，必须在声明时赋值，而且不可以重新赋值。（这里就不再举例其使用了）</li> <li>实际上，在开发中，应该尽量使用const来声明变量，以保证变量的值不会随意篡改，原因：</li></ul> <ol><li>根据经验，开发中的很多变量，都是不会更改，也不应该更改的。</li> <li>后续的很多框架或者是第三方JS库，都要求数据不可变，使用常量可以一定程度上保证这一点。</li></ol> <p><strong>注意</strong></p> <ol><li><p>常量不可变，是指声明的常量的内存空间不可变，并不保证内存空间中的地址指向的其他空间不可变</p></li> <li><p>常量的命名</p> <ol><li>特殊的常量：该常量从字面意义上，一定是不可变的，比如圆周率、月地距地或其他一些绝不可能变化的配置。通常，<strong>该常量的名称全部使用大写，多个单词之间用下划线分割</strong></li> <li>普通的常量：使用和之前一样的命名即可</li></ol></li> <li><p>在for循环中，循环变量不可以使用常量，只能用let 关于主义的第一点，我举个例子</p> <p>const a = {
name: &quot;kevin&quot;,
age: 123
};
a.name = &quot;abc&quot;;
console.log(a) // abc</p> <p>// const PI = 3.14;
// const MOON_EARTH_DISTANCE = 3245563424; //月地距离</p></li></ol> <h2 id="_3-顶层对象属性"><a href="#_3-顶层对象属性" class="header-anchor">#</a> 3. 顶层对象属性</h2> <ol><li><p>顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象</p> <p>var a = 1;
// 如果在 Node 的 REPL 环境，可以写成 global.a
// 或者采用通用方法，写成 this.a
window.a // 1</p> <p>let b = 1;
window.b // undefined let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性</p></li> <li><p>globalThis 对象 因为环境的不同，顶层对象在各种实现里面是不统一的</p> <ol><li>浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。</li> <li>浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。</li> <li>Node 里面，顶层对象是global，但其他环境都不支持。 在不同环境中获取顶层对象的this ES6 提供了两个方法</li></ol> <p>// 方法一
(typeof window !== 'undefined'
? window
: (typeof process === 'object' &amp;&amp;
typeof require === 'function' &amp;&amp;
typeof global === 'object')
? global
: this);</p> <p>// 方法二
var getGlobal = function () {
if (typeof self !== 'undefined') { return self; }
if (typeof window !== 'undefined') { return window; }
if (typeof global !== 'undefined') { return global; }
throw new Error('unable to locate global object');
};</p></li></ol> <p>而且，ES6最后提到：</p> <ul><li>ES2020 在语言标准的层面，引入globalThis作为顶层对象。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。</li> <li>垫片库global-this模拟了这个提案，可以在所有环境拿到globalThis。</li></ul> <h1 id="第三章、变量的解构赋值"><a href="#第三章、变量的解构赋值" class="header-anchor">#</a> 第三章、变量的解构赋值</h1> <ul><li>在此，我这里主要介绍工作中我们常用的几种解构赋值：</li></ul> <ol><li>对象的结构</li> <li>数组的结构</li> <li>参数的结构</li> <li>其他的结构</li></ol> <h2 id="_1-对象的结构"><a href="#_1-对象的结构" class="header-anchor">#</a> 1. 对象的结构</h2> <p><strong>1. 什么是解构</strong></p> <ul><li><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring） <strong>解构不会对被解构的目标造成任何影响</strong></p></li> <li><p><strong>在解构中使用默认值</strong></p> <p>{同名变量 = 默认值}
const user = {
name: &quot;kevin&quot;,
age: 11,
sex: &quot;男&quot;,
address: {
province: &quot;四川&quot;,
city: &quot;成都&quot;
}
}
//解构出user中的name、province
//定义两个变量name、province
//再解构
const { name, address: { province } } = user;
console.log(name, province)
// name: kevin  province: 四川</p></li> <li><p><strong>非同名属性解构</strong></p> <p>{属性名:变量名}
let obj = {};
let arr = [];
({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });
obj // {prop:123}
arr // [true]
//如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错</p> <p>let {foo: {bar}} = {baz: 'baz'};
// 报错</p></li></ul> <h2 id="_2-数组的结构"><a href="#_2-数组的结构" class="header-anchor">#</a> 2. 数组的结构</h2> <div class="language- extra-class"><pre><code>let [a, b, c] = [1, 2, 3];
// a:1 b:2 c:3
</code></pre></div><p>这种写法属于<strong>模式匹配</strong>，只要等号两边的模式相同，左边的变量就会被赋予对应的值</p> <ul><li><p>下面一些使用嵌套数组进行解构的例子以及一些情况</p> <p>let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1    bar // 2    baz // 3</p> <p>let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];
third // &quot;baz&quot;</p> <p>// 1. 不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。
let [x, y] = [1, 2, 3];
x // 1  y // 2</p> <p>let [a, [b], d] = [1, [2, 3], 4];
a // 1  b // 2  d // 4
// 2. 数组解构出 值和数组（运用扩展运算符... 在接下来的章节里会就介绍到）</p> <p>let [head, ...tail] = [1, 2, 3, 4];
head // 1   tail // [2, 3, 4]</p> <p>// 3. 如果解构不成功，变量的值就等于undefined。</p> <p>let [x, y, ...z] = ['a'];
x // &quot;a&quot;    y // undefined  z // []</p> <p>// 4. 如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。</p> <p>// 4.1 要么转为对象以后不具备 Iterator 接口</p> <p>let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;</p> <p>// 4.2 本身就不具备 Iterator 接口</p> <p>let [foo] = {};</p></li></ul> <p>从最后的例子可以看出，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</p> <div class="language- extra-class"><pre><code>function* fibs() {
  let a = 0;
  let b = 1;
  while (true) {
    yield a;
    [a, b] = [b, a + b];
  }
}

let [first, second, third, fourth, fifth, sixth] = fibs();
sixth // 5
</code></pre></div><p>上面代码中，fibs是一个 Generator 函数（参见《Generator 函数》一章），原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。</p> <h2 id="_3-参数的结构"><a href="#_3-参数的结构" class="header-anchor">#</a> 3. 参数的结构</h2> <p>废话不多说，直接上例子</p> <div class="language- extra-class"><pre><code>function add([x, y]){
  return x + y;
}
add([1, 2]); // 3
// 函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。
// 对于函数内部的代码来说，它们能感受到的参数就是x和y。
</code></pre></div><p>箭头函数也可以解构赋值</p> <div class="language- extra-class"><pre><code>[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);
// [ 3, 7 ]
</code></pre></div><p>函数参数的解构也可以使用<strong>默认值</strong> 在第五章会给出介绍</p> <div class="language- extra-class"><pre><code>function move({x = 0, y = 0} = {}) { //x y 在参数上设置默认值
  return [x, y];
}
move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, 0]
move({}); // [0, 0]
move(); // [0, 0]
// 函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。
// 如果解构失败，x和y等于默认值。
</code></pre></div><p>undefined就会触发函数参数的默认值。</p> <div class="language- extra-class"><pre><code>[1, undefined, 3].map((x = 'yes') =&gt; x);
// [ 1, 'yes', 3 ]
</code></pre></div><h2 id="_4-其他的解构"><a href="#_4-其他的解构" class="header-anchor">#</a> 4. 其他的解构</h2> <ol><li><p>对象的解构也可以指定默认值 设置<strong>默认值</strong></p> <p>var {x = 3} = {};
x // 3</p> <p>var {x, y = 5} = {x: 1};
x // 1
y // 5</p> <p>var {x: y = 3} = {};
y // 3</p> <p>var {x: y = 3} = {x: 5};
y // 5</p> <p>var { message: msg = 'Something went wrong' } = {};
msg // &quot;Something went wrong&quot;</p></li></ol> <ul><li><p>默认值生效的条件是，对象的属性值严格等于undefined。</p> <p>var {x = 3} = {x: undefined};
x // 3</p> <p>var {x = 3} = {x: null};
x // null  因为null与undefined不严格相等，所以是个有效的赋值，导致默认值3不会生效</p></li></ul> <p><strong>注意点</strong></p> <ol><li><p>如果要将一个已经声明的变量用于解构赋值，必须非常小心。</p> <p>// 错误的写法
let x;
{x} = {x: 1};
// SyntaxError: syntax error因为JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。
// 只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。
// 正确的写法
let x;
({x} = {x: 1});</p></li> <li><p>解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式</p> <p>({} = [true, false]);
({} = 'abc');
({} = []);</p></li> <li><p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p> <p>let arr = [1, 2, 3];
let {0 : first, [arr.length - 1] : last} = arr;
first // 1
last // 3</p></li></ol> <h1 id="第四章、字符串的扩展"><a href="#第四章、字符串的扩展" class="header-anchor">#</a> 第四章、字符串的扩展</h1> <h2 id="_1-更好的unicode支持"><a href="#_1-更好的unicode支持" class="header-anchor">#</a> 1. 更好的Unicode支持</h2> <p>首先，介绍一下码元：</p> <ol><li>早期，由于存储空间宝贵，Unicode使用16位二进制来存储文字。我们将一个16位的二进制编码叫做一个<strong>码元（Code Unit）</strong>。后来，由于技术的发展，Unicode对文字编码进行了扩展，将某些文字扩展到了32位（占用两个码元），并且，将某个文字对应的二进制数字叫做<strong>码点（Code Point）</strong>。</li></ol> <p>ES6为了解决这个困扰，为字符串提供了方法：codePointAt，根据字符串码元的位置得到其码点。</p> <p>同时，ES6为正则表达式添加了一个flag: u，如果添加了该配置，则匹配时，使用码点匹配</p> <div class="language- extra-class"><pre><code>const text = &quot;𠮷&quot;; //占用了两个码元（32位）

console.log(&quot;字符串长度：&quot;, text.length); // 2
console.log(&quot;使用正则测试：&quot;, /^.$/u.test(text)); // true
console.log(&quot;得到第一个码元：&quot;, text.charCodeAt(0)); // 55362
console.log(&quot;得到第二个码元：&quot;, text.charCodeAt(1)); // 57271

//𠮷：\ud842\udfb7
console.log(&quot;得到第一个码点：&quot;, text.codePointAt(0)); // 134071
console.log(&quot;得到第二个码点：&quot;, text.codePointAt(1)); // 57271
</code></pre></div><p>然后我们完成一个自己的<strong>判断字符串char，是32位，还是16位</strong>方法</p> <div class="language- extra-class"><pre><code>function is32bit(char, i) {
    //如果码点大于了16位二进制的最大值，则其是32位的
    return char.codePointAt(i) &gt; 0xffff;
}
</code></pre></div><p>得到一个字符串码点的真实长度</p> <div class="language- extra-class"><pre><code>function getLengthOfCodePoint(str) {
    var len = 0;
    for (let i = 0; i &lt; str.length; i++) {
        //i在索引码元
        if (is32bit(str, i)) {
            //当前字符串，在i这个位置，占用了两个码元
            i++;
        }
        len++;
    }
    return len;
}

console.log(&quot;𠮷是否是32位的：&quot;, is32bit(&quot;𠮷&quot;, 0)) // 𠮷是否是32位的： true
console.log(&quot;ab𠮷ab的码点长度：&quot;, getLengthOfCodePoint(&quot;ab𠮷ab&quot;)) // ab𠮷ab的码点长度： 5
</code></pre></div><h2 id="_2-增加的字符串api-只举出工作中常用的四种"><a href="#_2-增加的字符串api-只举出工作中常用的四种" class="header-anchor">#</a> 2. 增加的字符串API(只举出工作中常用的四种)</h2> <ul><li><p>includes 判断字符串中是否包含指定的子字符串</p></li> <li><p>startsWith 判断字符串中是否以指定的字符串开始</p></li> <li><p>endsWith 判断字符串中是否以指定的字符串结尾</p></li> <li><p>repeat 将字符串重复指定的次数，然后返回一个新字符串</p> <p>const text = &quot;我真是狠人&quot;;</p> <p>console.log(&quot;是否包含“狠”：&quot;, text.includes(&quot;狠&quot;));
console.log(&quot;是否以“我”开头：&quot;, text.startsWith(&quot;我&quot;));
console.log(&quot;是否以“狠人”结尾：&quot;,</p> <p>text.endsWith(&quot;狠人&quot;));
console.log(&quot;重复4次：&quot;, text.repeat(4));
// 由于过于简单，就不把console结果展示啦，有兴趣的可以直接试一下，哈哈哈</p></li></ul> <h2 id="_3-模板字符串"><a href="#_3-模板字符串" class="header-anchor">#</a> 3. 模板字符串</h2> <p><strong>模板字符串是此章节的灵魂</strong></p> <ul><li>ES6之前处理字符串繁琐的两个方面：</li></ul> <ol><li>多行字符串</li> <li>字符串拼接</li></ol> <ul><li>在ES6中，提供了模板字符串的书写，可以非常方便的换行和拼接，要做的，仅仅是将字符串的开始或结尾改为 ` 符号</li></ul> <p>如果要在字符串中拼接js表达式，只需要在模板字符串中使用<code>${JS表达式}</code></p> <div class="language- extra-class"><pre><code>var love1 = &quot;秋葵&quot;;
var love2 = &quot;香菜&quot;;

var text = `A喜欢${love1}
B也喜欢${love2}
表达式可以是任何有意义的数据${1 + 3 * 2 / 0.5}
表达式是可以嵌套的：${`表达式中的模板字符串${love1 + love2}`}
\n\n
奥布瓦的发顺丰
在模板字符串中使用\${JS表达式}可以进行插值
`;

console.log(text);
</code></pre></div><p>在模板字符串书写之前，可以加上标记:</p> <div class="language- extra-class"><pre><code>标记名`模板字符串`
</code></pre></div><p>标记是一个函数，函数参数如下：</p> <ol><li><p>参数1：被插值分割的字符串数组</p></li> <li><p>后续参数：所有的插值</p> <p>var love1 = &quot;秋葵&quot;;
var love2 = &quot;香菜&quot;;</p> <p>var text = myTag<code>邓哥喜欢${love1}，邓哥也喜欢${love2}。</code>;</p> <p>//相当于：
// text = myTag([&quot;A喜欢&quot;, &quot;，B也喜欢&quot;, &quot;。&quot;], &quot;秋葵&quot;, &quot;香菜&quot;)</p> <p>function myTag(parts) {
const values = Array.prototype.slice.apply(arguments).slice(1);
let str = &quot;&quot;;
for (let i = 0; i &lt; values.length; i++) {
str += <code>${parts[i]}：${values[i]}</code>;
if (i === values.length - 1) {
str += parts[i + 1];
}
}
return str;
}</p> <p>console.log(text); //A喜欢：秋葵，B也喜欢：香菜</p></li></ol> <h1 id="第五章、函数的扩展"><a href="#第五章、函数的扩展" class="header-anchor">#</a> 第五章、函数的扩展</h1> <h2 id="_1-在书写形参时，直接给形参赋值，附的值即为默认值（在解构的时候有过应用）"><a href="#_1-在书写形参时，直接给形参赋值，附的值即为默认值（在解构的时候有过应用）" class="header-anchor">#</a> 1. 在书写形参时，直接给形参赋值，附的值即为<strong>默认值</strong>（在解构的时候有过应用）</h2> <p>这样一来，当调用函数时，如果没有给对应的参数赋值（给它的值是undefined），则会自动使用默认值</p> <ol><li>留意暂时性死区 形参</li></ol> <ul><li>和ES6中的let或const声明一样，具有作用域，并且根据参数的声明顺序，存在暂时性死区。</li></ul> <ol start="2"><li>对arguments的影响</li></ol> <ul><li><p>只要给函数加上参数默认值，该函数会自动变量严格模式下的规则：arguments和形参脱离</p></li> <li><p>暂时性死区</p> <p>function test(a = b, b) {
console.log(a, b);
}
test(undefined, 2);// 报错 因为传a值undefined, 然后会给a赋默认值 b ,但是此时 b还没有赋值，所以报错。在上边解构赋值中也介绍过</p> <p>function sum(a, b = 1, c = 2) {
return a + b + c;
}</p> <p>console.log(sum(10, undefined, undefined))
console.log(sum(11))
console.log(sum(1, undefined, 5))  // 这种情况才是正常</p></li> <li><p>对arguments的影响</p> <p>function test(a, b = 1) {
console.log(&quot;arugments&quot;, arguments[0], arguments[1]); //arugments 1 2
console.log(&quot;a:&quot;, a, &quot;b:&quot;, b); //a: 1 b: 2
a = 3;
console.log(&quot;arugments&quot;, arguments[0], arguments[1]); //arugments 1 2
console.log(&quot;a:&quot;, a, &quot;b:&quot;, b); //a: 3 b: 2
}</p> <p>test(1, 2);</p></li></ul> <h2 id="es6的剩余参数专门用于手机末尾的所有参数，将其放置到一个形参数组中。语法"><a href="#es6的剩余参数专门用于手机末尾的所有参数，将其放置到一个形参数组中。语法" class="header-anchor">#</a> ES6的剩余参数专门用于手机末尾的所有参数，将其放置到一个形参数组中。语法:</h2> <div class="language- extra-class"><pre><code>function (...形参名){

}
</code></pre></div><p><strong>注意：</strong></p> <ol><li><p>一个函数，仅能出现一个剩余参数</p></li> <li><p>一个函数，如果有剩余参数，剩余参数必须是最后一个参数</p> <p>function test(a, b, ...args) {
console.log(a, b, args);
}</p> <p>test(1, 32, 46, 7, 34); //1 32 [46, 7, 34]</p></li></ol> <h2 id="_2-展开运算符：-要展开的东西"><a href="#_2-展开运算符：-要展开的东西" class="header-anchor">#</a> 2. 展开运算符：<code>...要展开的东西</code></h2> <div class="language- extra-class"><pre><code>const arr1 = [3, 67, 8, 5];

//克隆arr1数组到arr2

const arr2 = [0, ...arr1, 1];

console.log(arr2, arr1 === arr2)
// -------------------------------------
const obj1 = {
    name: &quot;A&quot;,
    age: 18,
    love: &quot;B&quot;,
    address: {
        country: &quot;中国&quot;,
        province: &quot;BJ&quot;,
        city: &quot;BJ&quot;
    }
}

// 浅克隆到obj2

const obj2 = {
    ...obj1,
    name: &quot;C&quot;
};

console.log(obj2)

console.log(obj1.address === obj2.address)
</code></pre></div><h2 id="_3-明确函数的双重用途"><a href="#_3-明确函数的双重用途" class="header-anchor">#</a> 3. 明确函数的双重用途</h2> <p>ES6提供了一个特殊的API，可以使用该API在函数内部，判断该函数是否使用了new来调用</p> <div class="language- extra-class"><pre><code>new.target 
//该表达式，得到的是：如果没有使用new来调用函数，则返回undefined
//如果使用new调用函数，则得到的是new关键字后面的函数本身

function Person(firstName, lastName) {
    //判断是否是使用new的方式来调用的函数

    // //过去的判断方式
    // if (!(this instanceof Person)) {
    //     throw new Error(&quot;该函数没有使用new来调用&quot;)
    // }

    if (new.target === undefined) {
        throw new Error(&quot;该函数没有使用new来调用&quot;)
    }
    this.firstName = firstName;
    this.lastName = lastName;
    this.fullName = `${firstName} ${lastName}`;
}

const p1 = new Person(&quot;张&quot;, &quot;三&quot;);
console.log(p1)



const p2 = Person(&quot;张&quot;, &quot;三&quot;);
console.log(p2); // 报错，该函数没有使用new来调用

const p3 = Person.call(p1, &quot;张&quot;, &quot;三&quot;)
console.log(p3);// 报错，该函数没有使用new来调用
</code></pre></div><h2 id="_4-箭头函数"><a href="#_4-箭头函数" class="header-anchor">#</a> 4. 箭头函数</h2> <ol><li><p>ES5中this的问题（本文主要是来介绍ES6的，暂且将之前的总结直接放在这里，在之后的博文中会仔细描述一下ES5系列）</p> <ol><li>通过对象调用函数，this指向对象</li> <li>直接调用函数，this指向全局对象</li> <li>如果通过new调用函数，this指向新创建的对象</li> <li>如果通过apply、call、bind调用函数，this指向指定的数据</li> <li>如果是DOM事件函数，this指向事件源</li></ol></li> <li><p>箭头函数是一个函数表达式，理论上，任何使用函数表达式的场景都可以使用箭头函数</p></li></ol> <p>完整语法：</p> <div class="language- extra-class"><pre><code>(参数1, 参数2, ...)=&gt;{
    //函数体
}
</code></pre></div><p>如果参数只有一个，可以省略小括号</p> <div class="language- extra-class"><pre><code>参数 =&gt; {

}
</code></pre></div><p>如果箭头函数只有一条返回语句，可以省略大括号，和return关键字</p> <div class="language- extra-class"><pre><code>参数 =&gt; 返回值


const print = num =&gt; {
    console.log(&quot;给我的数字是：&quot;, num)
}
print(2);

const arr = [1,2,4,56,22,43,23,2,23,12,1];
arr.sort((a, b)=&gt; a - b);
console.log(arr);
</code></pre></div><p><strong>注意</strong></p> <ul><li><p>箭头函数中，不存在this、arguments、new.target，如果使用了，则使用的是函数外层的对应的this、arguments、new.target 也就是说<strong>在箭头函数中，this是固定的。因为箭头函数本身就是引用的外层函数的this</strong></p></li> <li><p>箭头函数没有原型</p></li> <li><p>箭头函数不能作用构造函数使用</p></li> <li><p>不可以使用yield命令，因此箭头函数不能用作 Generator 函数</p> <p>// ES6
function foo() {
setTimeout(() =&gt; {
console.log('id:', this.id);
}, 100);
}</p> <p>// ES5
function foo() {
var _this = this;</p> <p>setTimeout(function () {
console.log('id:', _this.id);
}, 100);
}</p></li></ul> <p>除了this，arguments、super、new.target这三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。</p> <div class="language- extra-class"><pre><code>function foo() {
  setTimeout(() =&gt; {
    console.log('args:', arguments);
  }, 100);
}

foo(2, 4, 6, 8)
// args: [2, 4, 6, 8]
</code></pre></div><p>另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。</p> <div class="language- extra-class"><pre><code>(function() {
  return [
    (() =&gt; this.x).bind({ x: 'inner' })()
  ];
}).call({ x: 'outer' });
// ['outer']
//代码中，箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this。
</code></pre></div><p><strong>应用比较多的场景</strong></p> <ol><li>临时性使用的函数，并不会可以调用它，比如：
<ol><li>事件处理函数</li> <li>异步处理函数</li> <li>其他临时性的函数</li></ol></li> <li>为了绑定外层this的函数</li> <li>在不影响其他代码的情况下，保持代码的简洁，最常见的，数组方法中的回调函数</li></ol> <p>本文主要引用阮一峰老师的《ECMAScript6简介》</p> <h2 id="js相关"><a href="#js相关" class="header-anchor">#</a> js相关</h2> <p>1.预留
代码的语法</p> <p>2.单行</p> <div class="language- extra-class"><pre><code>create database hero;  
</code></pre></div><p>3.多行的</p> <div class="language- extra-class"><pre><code>function fun(){  
     echo &quot;这是一句非常牛逼的代码&quot;;  
}  
fun();
</code></pre></div><h2 id="vuejs相关"><a href="#vuejs相关" class="header-anchor">#</a> vuejs相关</h2> <p>1.预留</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.f16b6530.js" defer></script><script src="/assets/js/2.efd5ddf9.js" defer></script><script src="/assets/js/3.1fdb5907.js" defer></script>
  </body>
</html>
